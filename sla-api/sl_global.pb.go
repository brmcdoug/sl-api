// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_global.proto

package service_layer

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Global Event Notification types.
type SLGlobalNotifType int32

const (
	// Reserved. 0x0
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_RESERVED SLGlobalNotifType = 0
	// Error. ErrStatus field elaborates on the message. 0x1
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_ERROR SLGlobalNotifType = 1
	// HeartBeat. 0x2
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_HEARTBEAT SLGlobalNotifType = 2
	// Version. SLInitMsgRsp field elaborates on the server version. 0x3
	SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_VERSION SLGlobalNotifType = 3
)

var SLGlobalNotifType_name = map[int32]string{
	0: "SL_GLOBAL_EVENT_TYPE_RESERVED",
	1: "SL_GLOBAL_EVENT_TYPE_ERROR",
	2: "SL_GLOBAL_EVENT_TYPE_HEARTBEAT",
	3: "SL_GLOBAL_EVENT_TYPE_VERSION",
}

var SLGlobalNotifType_value = map[string]int32{
	"SL_GLOBAL_EVENT_TYPE_RESERVED":  0,
	"SL_GLOBAL_EVENT_TYPE_ERROR":     1,
	"SL_GLOBAL_EVENT_TYPE_HEARTBEAT": 2,
	"SL_GLOBAL_EVENT_TYPE_VERSION":   3,
}

func (x SLGlobalNotifType) String() string {
	return proto.EnumName(SLGlobalNotifType_name, int32(x))
}

func (SLGlobalNotifType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{0}
}

// Initialization message sent to the server.
// If the client and server are running compatible version numbers, a
// connection will be made and the server response will be received
// with a successful status code.
type SLInitMsg struct {
	// Client's Major version of service-layer API (refer to sl_version.proto)
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer,proto3" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer,proto3" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer               uint32   `protobuf:"varint,3,opt,name=SubVer,proto3" json:"SubVer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLInitMsg) Reset()         { *m = SLInitMsg{} }
func (m *SLInitMsg) String() string { return proto.CompactTextString(m) }
func (*SLInitMsg) ProtoMessage()    {}
func (*SLInitMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{0}
}

func (m *SLInitMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLInitMsg.Unmarshal(m, b)
}
func (m *SLInitMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLInitMsg.Marshal(b, m, deterministic)
}
func (m *SLInitMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLInitMsg.Merge(m, src)
}
func (m *SLInitMsg) XXX_Size() int {
	return xxx_messageInfo_SLInitMsg.Size(m)
}
func (m *SLInitMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLInitMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLInitMsg proto.InternalMessageInfo

func (m *SLInitMsg) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *SLInitMsg) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *SLInitMsg) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Server's response to the SLInitMsg.
// On Success (ErrStatus), the session with the server is established
// and the client is allowed to proceed.
type SLInitMsgRsp struct {
	// Server's version of service-layer API (refer to sl_version.proto)
	// Major-number revisions are NOT backwards compatible,
	// unless otherwise specified. The Server may reject a session if there
	// is a version number mismatch or non-backwards compatibility.
	MajorVer uint32 `protobuf:"varint,1,opt,name=MajorVer,proto3" json:"MajorVer,omitempty"`
	// Minor Version
	MinorVer uint32 `protobuf:"varint,2,opt,name=MinorVer,proto3" json:"MinorVer,omitempty"`
	// Sub-Version
	SubVer               uint32   `protobuf:"varint,3,opt,name=SubVer,proto3" json:"SubVer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLInitMsgRsp) Reset()         { *m = SLInitMsgRsp{} }
func (m *SLInitMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLInitMsgRsp) ProtoMessage()    {}
func (*SLInitMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{1}
}

func (m *SLInitMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLInitMsgRsp.Unmarshal(m, b)
}
func (m *SLInitMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLInitMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLInitMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLInitMsgRsp.Merge(m, src)
}
func (m *SLInitMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLInitMsgRsp.Size(m)
}
func (m *SLInitMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLInitMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLInitMsgRsp proto.InternalMessageInfo

func (m *SLInitMsgRsp) GetMajorVer() uint32 {
	if m != nil {
		return m.MajorVer
	}
	return 0
}

func (m *SLInitMsgRsp) GetMinorVer() uint32 {
	if m != nil {
		return m.MinorVer
	}
	return 0
}

func (m *SLInitMsgRsp) GetSubVer() uint32 {
	if m != nil {
		return m.SubVer
	}
	return 0
}

// Globals query message.
type SLGlobalNotif struct {
	// Event Type.
	EventType SLGlobalNotifType `protobuf:"varint,1,opt,name=EventType,proto3,enum=service_layer.SLGlobalNotifType" json:"EventType,omitempty"`
	// Status code, interpreted based on the Event Type.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_ERROR:
	//       case ErrStatus == SL_NOTIF_TERM:
	//          => Another client is attempting to take over the session.
	//             This session will be closed.
	//       case ErrStatus == (some error from SLErrorStatus)
	//          => Client must look into the specific error message returned.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_HEARTBEAT:
	//       case ErrStatus == SL_SUCCESS
	//          => Client can safely ignore this heartbeat message.
	//
	//   case EventType == SL_GLOBAL_EVENT_TYPE_VERSION:
	//       case ErrStatus == SL_SUCCESS
	//          => Client version accepted.
	//       case ErrStatus == SL_INIT_STATE_READY
	//          => Client version accepted.
	//             Any previous state was sucessfully recovered.
	//       case ErrStatus == SL_INIT_STATE_CLEAR
	//          => Client version accepted. Any previous state was lost.
	//             Client must replay all previous objects to server.
	//       case ErrStatus == SL_UNSUPPORTED_VER
	//          => Client and Server version mismatch. The client is not
	//             allowed to proceed, and the channel will be closed.
	//       case ErrStatus == (some error from SLErrorStatus)
	//          => Client must either try again, or look into the specific
	//             error message returned.
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Further info based on EventType.
	//
	// Types that are valid to be assigned to Event:
	//	*SLGlobalNotif_InitRspMsg
	Event                isSLGlobalNotif_Event `protobuf_oneof:"Event"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SLGlobalNotif) Reset()         { *m = SLGlobalNotif{} }
func (m *SLGlobalNotif) String() string { return proto.CompactTextString(m) }
func (*SLGlobalNotif) ProtoMessage()    {}
func (*SLGlobalNotif) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{2}
}

func (m *SLGlobalNotif) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLGlobalNotif.Unmarshal(m, b)
}
func (m *SLGlobalNotif) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLGlobalNotif.Marshal(b, m, deterministic)
}
func (m *SLGlobalNotif) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLGlobalNotif.Merge(m, src)
}
func (m *SLGlobalNotif) XXX_Size() int {
	return xxx_messageInfo_SLGlobalNotif.Size(m)
}
func (m *SLGlobalNotif) XXX_DiscardUnknown() {
	xxx_messageInfo_SLGlobalNotif.DiscardUnknown(m)
}

var xxx_messageInfo_SLGlobalNotif proto.InternalMessageInfo

func (m *SLGlobalNotif) GetEventType() SLGlobalNotifType {
	if m != nil {
		return m.EventType
	}
	return SLGlobalNotifType_SL_GLOBAL_EVENT_TYPE_RESERVED
}

func (m *SLGlobalNotif) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

type isSLGlobalNotif_Event interface {
	isSLGlobalNotif_Event()
}

type SLGlobalNotif_InitRspMsg struct {
	InitRspMsg *SLInitMsgRsp `protobuf:"bytes,3,opt,name=InitRspMsg,proto3,oneof"`
}

func (*SLGlobalNotif_InitRspMsg) isSLGlobalNotif_Event() {}

func (m *SLGlobalNotif) GetEvent() isSLGlobalNotif_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SLGlobalNotif) GetInitRspMsg() *SLInitMsgRsp {
	if x, ok := m.GetEvent().(*SLGlobalNotif_InitRspMsg); ok {
		return x.InitRspMsg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SLGlobalNotif) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SLGlobalNotif_OneofMarshaler, _SLGlobalNotif_OneofUnmarshaler, _SLGlobalNotif_OneofSizer, []interface{}{
		(*SLGlobalNotif_InitRspMsg)(nil),
	}
}

func _SLGlobalNotif_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SLGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLGlobalNotif_InitRspMsg:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InitRspMsg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SLGlobalNotif.Event has unexpected type %T", x)
	}
	return nil
}

func _SLGlobalNotif_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SLGlobalNotif)
	switch tag {
	case 3: // Event.InitRspMsg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SLInitMsgRsp)
		err := b.DecodeMessage(msg)
		m.Event = &SLGlobalNotif_InitRspMsg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SLGlobalNotif_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SLGlobalNotif)
	// Event
	switch x := m.Event.(type) {
	case *SLGlobalNotif_InitRspMsg:
		s := proto.Size(x.InitRspMsg)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Globals query message.
type SLGlobalsGetMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLGlobalsGetMsg) Reset()         { *m = SLGlobalsGetMsg{} }
func (m *SLGlobalsGetMsg) String() string { return proto.CompactTextString(m) }
func (*SLGlobalsGetMsg) ProtoMessage()    {}
func (*SLGlobalsGetMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{3}
}

func (m *SLGlobalsGetMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLGlobalsGetMsg.Unmarshal(m, b)
}
func (m *SLGlobalsGetMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLGlobalsGetMsg.Marshal(b, m, deterministic)
}
func (m *SLGlobalsGetMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLGlobalsGetMsg.Merge(m, src)
}
func (m *SLGlobalsGetMsg) XXX_Size() int {
	return xxx_messageInfo_SLGlobalsGetMsg.Size(m)
}
func (m *SLGlobalsGetMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLGlobalsGetMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLGlobalsGetMsg proto.InternalMessageInfo

// Platform specific globals Response.
type SLGlobalsGetMsgRsp struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Maximum vrf name length.
	MaxVrfNameLength uint32 `protobuf:"varint,2,opt,name=MaxVrfNameLength,proto3" json:"MaxVrfNameLength,omitempty"`
	// Maximum interface name length.
	MaxInterfaceNameLength uint32 `protobuf:"varint,3,opt,name=MaxInterfaceNameLength,proto3" json:"MaxInterfaceNameLength,omitempty"`
	// Maximum paths per Route/ILM Entry.
	MaxPathsPerEntry uint32 `protobuf:"varint,4,opt,name=MaxPathsPerEntry,proto3" json:"MaxPathsPerEntry,omitempty"`
	// Maximum primary paths per Route/ILM Entry.
	MaxPrimaryPathPerEntry uint32 `protobuf:"varint,5,opt,name=MaxPrimaryPathPerEntry,proto3" json:"MaxPrimaryPathPerEntry,omitempty"`
	// Maximum backup paths per Route/ILM Entry.
	MaxBackupPathPerEntry uint32 `protobuf:"varint,6,opt,name=MaxBackupPathPerEntry,proto3" json:"MaxBackupPathPerEntry,omitempty"`
	// Maximum MPLS labels per Route/ILM Entry.
	MaxMplsLabelsPerPath uint32 `protobuf:"varint,7,opt,name=MaxMplsLabelsPerPath,proto3" json:"MaxMplsLabelsPerPath,omitempty"`
	// Minimum Primary path id number.
	MinPrimaryPathIdNum uint32 `protobuf:"varint,8,opt,name=MinPrimaryPathIdNum,proto3" json:"MinPrimaryPathIdNum,omitempty"`
	// Maximum Primary path id number.
	MaxPrimaryPathIdNum uint32 `protobuf:"varint,9,opt,name=MaxPrimaryPathIdNum,proto3" json:"MaxPrimaryPathIdNum,omitempty"`
	// Minimum Pure Backup path id number.
	MinBackupPathIdNum uint32 `protobuf:"varint,10,opt,name=MinBackupPathIdNum,proto3" json:"MinBackupPathIdNum,omitempty"`
	// Maximum Pure Backup path id number.
	MaxBackupPathIdNum uint32 `protobuf:"varint,11,opt,name=MaxBackupPathIdNum,proto3" json:"MaxBackupPathIdNum,omitempty"`
	// Maximum number of remote addresses
	MaxRemoteAddressNum  uint32   `protobuf:"varint,12,opt,name=MaxRemoteAddressNum,proto3" json:"MaxRemoteAddressNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLGlobalsGetMsgRsp) Reset()         { *m = SLGlobalsGetMsgRsp{} }
func (m *SLGlobalsGetMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLGlobalsGetMsgRsp) ProtoMessage()    {}
func (*SLGlobalsGetMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e53fa408f7a329a, []int{4}
}

func (m *SLGlobalsGetMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLGlobalsGetMsgRsp.Unmarshal(m, b)
}
func (m *SLGlobalsGetMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLGlobalsGetMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLGlobalsGetMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLGlobalsGetMsgRsp.Merge(m, src)
}
func (m *SLGlobalsGetMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLGlobalsGetMsgRsp.Size(m)
}
func (m *SLGlobalsGetMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLGlobalsGetMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLGlobalsGetMsgRsp proto.InternalMessageInfo

func (m *SLGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLGlobalsGetMsgRsp) GetMaxVrfNameLength() uint32 {
	if m != nil {
		return m.MaxVrfNameLength
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxInterfaceNameLength() uint32 {
	if m != nil {
		return m.MaxInterfaceNameLength
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPathsPerEntry() uint32 {
	if m != nil {
		return m.MaxPathsPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPrimaryPathPerEntry() uint32 {
	if m != nil {
		return m.MaxPrimaryPathPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxBackupPathPerEntry() uint32 {
	if m != nil {
		return m.MaxBackupPathPerEntry
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxMplsLabelsPerPath() uint32 {
	if m != nil {
		return m.MaxMplsLabelsPerPath
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMinPrimaryPathIdNum() uint32 {
	if m != nil {
		return m.MinPrimaryPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxPrimaryPathIdNum() uint32 {
	if m != nil {
		return m.MaxPrimaryPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMinBackupPathIdNum() uint32 {
	if m != nil {
		return m.MinBackupPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxBackupPathIdNum() uint32 {
	if m != nil {
		return m.MaxBackupPathIdNum
	}
	return 0
}

func (m *SLGlobalsGetMsgRsp) GetMaxRemoteAddressNum() uint32 {
	if m != nil {
		return m.MaxRemoteAddressNum
	}
	return 0
}

func init() {
	proto.RegisterEnum("service_layer.SLGlobalNotifType", SLGlobalNotifType_name, SLGlobalNotifType_value)
	proto.RegisterType((*SLInitMsg)(nil), "service_layer.SLInitMsg")
	proto.RegisterType((*SLInitMsgRsp)(nil), "service_layer.SLInitMsgRsp")
	proto.RegisterType((*SLGlobalNotif)(nil), "service_layer.SLGlobalNotif")
	proto.RegisterType((*SLGlobalsGetMsg)(nil), "service_layer.SLGlobalsGetMsg")
	proto.RegisterType((*SLGlobalsGetMsgRsp)(nil), "service_layer.SLGlobalsGetMsgRsp")
}

func init() { proto.RegisterFile("sl_global.proto", fileDescriptor_8e53fa408f7a329a) }

var fileDescriptor_8e53fa408f7a329a = []byte{
	// 588 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xdf, 0x6a, 0xdb, 0x30,
	0x14, 0xc6, 0xeb, 0xfe, 0xcf, 0x69, 0xbb, 0xa6, 0xda, 0x5a, 0x42, 0xd6, 0x95, 0x36, 0x57, 0xa3,
	0x17, 0xa1, 0x64, 0x63, 0x17, 0x83, 0x0d, 0x12, 0x26, 0xd2, 0x80, 0x9d, 0x64, 0x72, 0x08, 0x8c,
	0xc1, 0x8c, 0x92, 0x28, 0xa9, 0x37, 0xff, 0x43, 0x52, 0x4a, 0xf2, 0x2e, 0x7b, 0x84, 0xbd, 0xcd,
	0x5e, 0x66, 0x97, 0xc3, 0xb2, 0x6b, 0xc7, 0xb5, 0x53, 0x18, 0xec, 0x52, 0xfa, 0x7d, 0x9f, 0xcf,
	0xa7, 0x63, 0xce, 0x81, 0x63, 0xe1, 0x58, 0x33, 0xc7, 0x1f, 0x51, 0xa7, 0x1e, 0x70, 0x5f, 0xfa,
	0xe8, 0x48, 0x30, 0x7e, 0x6f, 0x8f, 0x99, 0xe5, 0xd0, 0x25, 0xe3, 0xd5, 0x53, 0xe1, 0x58, 0x63,
	0xdf, 0x75, 0x7d, 0xcf, 0x92, 0xcb, 0x80, 0x89, 0x48, 0x55, 0xfb, 0x0a, 0x25, 0x53, 0xef, 0x78,
	0xb6, 0x34, 0xc4, 0x0c, 0x55, 0x61, 0xdf, 0xa0, 0xdf, 0x7d, 0x3e, 0x64, 0xbc, 0xa2, 0x5d, 0x6a,
	0xaf, 0x8f, 0x48, 0x72, 0x56, 0xcc, 0xf6, 0x22, 0xb6, 0x19, 0xb3, 0xf8, 0x8c, 0xce, 0x60, 0xd7,
	0x9c, 0x8f, 0x42, 0xb2, 0xa5, 0x48, 0x7c, 0xaa, 0x7d, 0x83, 0xc3, 0xe4, 0xe3, 0x44, 0x04, 0xff,
	0xfd, 0xfb, 0xbf, 0x35, 0x38, 0x32, 0xf5, 0xb6, 0x7a, 0x75, 0xd7, 0x97, 0xf6, 0x14, 0x7d, 0x84,
	0x12, 0xbe, 0x67, 0x9e, 0x1c, 0x2c, 0x03, 0xa6, 0x4a, 0x3c, 0x6b, 0x5c, 0xd6, 0x33, 0x8d, 0xa8,
	0x67, 0x0c, 0xa1, 0x8e, 0xa4, 0x16, 0xf4, 0x1e, 0x4a, 0x98, 0x73, 0x53, 0x52, 0x39, 0x17, 0x2a,
	0xc6, 0x41, 0xe3, 0x3c, 0xe7, 0xc7, 0x9c, 0xfb, 0xb1, 0x86, 0xa4, 0x72, 0xf4, 0x01, 0x20, 0x7c,
	0x2b, 0x11, 0x81, 0x21, 0x66, 0x2a, 0xe9, 0x41, 0xe3, 0x65, 0xce, 0x9c, 0xb6, 0xe3, 0x76, 0x83,
	0xac, 0x18, 0x5a, 0x7b, 0xb0, 0xa3, 0x72, 0xd4, 0x4e, 0xe0, 0xf8, 0x21, 0xa3, 0x68, 0xb3, 0x50,
	0x5c, 0xfb, 0xb3, 0x0d, 0xe8, 0xd1, 0x5d, 0xd8, 0xcf, 0x4c, 0x5a, 0xed, 0xdf, 0xd2, 0x5e, 0x43,
	0xd9, 0xa0, 0x8b, 0x21, 0x9f, 0x76, 0xa9, 0xcb, 0x74, 0xe6, 0xcd, 0xe4, 0x5d, 0xdc, 0xf7, 0xdc,
	0x3d, 0x7a, 0x07, 0x67, 0x06, 0x5d, 0x74, 0x3c, 0xc9, 0xf8, 0x94, 0x8e, 0xd9, 0x8a, 0x23, 0xfa,
	0x1f, 0x6b, 0x68, 0x5c, 0xa3, 0x4f, 0xe5, 0x9d, 0xe8, 0x33, 0x8e, 0x3d, 0xc9, 0x97, 0x95, 0xed,
	0xa4, 0x46, 0xe6, 0x3e, 0xae, 0xd1, 0xe7, 0xb6, 0x4b, 0xf9, 0x32, 0x44, 0x89, 0x63, 0x27, 0xa9,
	0x51, 0x40, 0xd1, 0x5b, 0x38, 0x35, 0xe8, 0xa2, 0x45, 0xc7, 0x3f, 0xe6, 0x41, 0xc6, 0xb6, 0xab,
	0x6c, 0xc5, 0x10, 0x35, 0xe0, 0x85, 0x41, 0x17, 0x46, 0xe0, 0x08, 0x9d, 0x8e, 0x98, 0x13, 0xc6,
	0x08, 0x79, 0x65, 0x4f, 0x99, 0x0a, 0x19, 0xba, 0x81, 0xe7, 0x86, 0xed, 0xad, 0x64, 0xe8, 0x4c,
	0xba, 0x73, 0xb7, 0xb2, 0xaf, 0x2c, 0x45, 0x48, 0x39, 0x32, 0xa9, 0x23, 0x47, 0x29, 0x76, 0xe4,
	0x11, 0xaa, 0x03, 0x32, 0x6c, 0x2f, 0x0d, 0x1c, 0x19, 0x40, 0x19, 0x0a, 0x88, 0xd2, 0xaf, 0x3e,
	0x30, 0xd2, 0x1f, 0xc4, 0xfa, 0x1c, 0x89, 0x13, 0x11, 0xe6, 0xfa, 0x92, 0x35, 0x27, 0x13, 0xce,
	0x84, 0x08, 0x0d, 0x87, 0x49, 0xa2, 0xc7, 0xe8, 0xfa, 0xa7, 0x06, 0x27, 0xb9, 0x91, 0x41, 0x57,
	0xf0, 0xca, 0xd4, 0xad, 0xb6, 0xde, 0x6b, 0x35, 0x75, 0x0b, 0x0f, 0x71, 0x77, 0x60, 0x0d, 0xbe,
	0xf4, 0xb1, 0x45, 0xb0, 0x89, 0xc9, 0x10, 0x7f, 0x2a, 0x6f, 0xa0, 0x0b, 0xa8, 0x16, 0x4a, 0x30,
	0x21, 0x3d, 0x52, 0xd6, 0x50, 0x0d, 0x2e, 0x0a, 0xf9, 0x2d, 0x6e, 0x92, 0x41, 0x0b, 0x37, 0x07,
	0xe5, 0x4d, 0x74, 0x09, 0xe7, 0x85, 0x9a, 0x21, 0x26, 0x66, 0xa7, 0xd7, 0x2d, 0x6f, 0x35, 0x7e,
	0x69, 0xb0, 0xff, 0x10, 0x0f, 0x19, 0x69, 0xd4, 0x70, 0xb0, 0xa2, 0x95, 0x50, 0x59, 0x37, 0x82,
	0xd5, 0xf3, 0xa7, 0x36, 0xc3, 0x8d, 0x86, 0x3e, 0x87, 0xeb, 0x2b, 0x1d, 0x3a, 0x74, 0xb1, 0x46,
	0x1f, 0x4f, 0x64, 0xf5, 0xea, 0x69, 0x4e, 0x44, 0x30, 0xda, 0x55, 0x5b, 0xf7, 0xcd, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x2a, 0xef, 0xf1, 0x6e, 0xae, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SLGlobalClient is the client API for SLGlobal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLGlobalClient interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Service Layer connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the SLInitMsg
	// message. The server will reply with SL_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message SLGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - SLGlobalNotif.EventType = SL_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to SLGlobalNotif definition for further info.
	SLGlobalInitNotif(ctx context.Context, in *SLInitMsg, opts ...grpc.CallOption) (SLGlobal_SLGlobalInitNotifClient, error)
	// Get platform specific globals
	SLGlobalsGet(ctx context.Context, in *SLGlobalsGetMsg, opts ...grpc.CallOption) (*SLGlobalsGetMsgRsp, error)
}

type sLGlobalClient struct {
	cc *grpc.ClientConn
}

func NewSLGlobalClient(cc *grpc.ClientConn) SLGlobalClient {
	return &sLGlobalClient{cc}
}

func (c *sLGlobalClient) SLGlobalInitNotif(ctx context.Context, in *SLInitMsg, opts ...grpc.CallOption) (SLGlobal_SLGlobalInitNotifClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLGlobal_serviceDesc.Streams[0], "/service_layer.SLGlobal/SLGlobalInitNotif", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLGlobalSLGlobalInitNotifClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SLGlobal_SLGlobalInitNotifClient interface {
	Recv() (*SLGlobalNotif, error)
	grpc.ClientStream
}

type sLGlobalSLGlobalInitNotifClient struct {
	grpc.ClientStream
}

func (x *sLGlobalSLGlobalInitNotifClient) Recv() (*SLGlobalNotif, error) {
	m := new(SLGlobalNotif)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLGlobalClient) SLGlobalsGet(ctx context.Context, in *SLGlobalsGetMsg, opts ...grpc.CallOption) (*SLGlobalsGetMsgRsp, error) {
	out := new(SLGlobalsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLGlobal/SLGlobalsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SLGlobalServer is the server API for SLGlobal service.
type SLGlobalServer interface {
	// Initialize the connection, and setup a notification channel.
	// This MUST be the first call to setup the Service Layer connection.
	//
	// The caller MUST maintain the notification channel to be able to
	// communicate with the server.
	// If this channel is not properly established and maintained, all other
	// RPC requests are rejected.
	//
	// The caller must send its version information as part of the SLInitMsg
	// message. The server will reply with SL_GLOBAL_EVENT_TYPE_VERSION
	// that tells the caller whether he can proceed or not.
	// Refer to message SLGlobalNotif below for further details.
	//
	// After the version handshake, the notification channel is used for
	// "push" event notifications, such as:
	//    - SLGlobalNotif.EventType = SL_GLOBAL_EVENT_TYPE_HEARTBEAT
	//        heartbeat notification messages are sent to the client on
	//        a periodic basis.
	//    Refer to SLGlobalNotif definition for further info.
	SLGlobalInitNotif(*SLInitMsg, SLGlobal_SLGlobalInitNotifServer) error
	// Get platform specific globals
	SLGlobalsGet(context.Context, *SLGlobalsGetMsg) (*SLGlobalsGetMsgRsp, error)
}

func RegisterSLGlobalServer(s *grpc.Server, srv SLGlobalServer) {
	s.RegisterService(&_SLGlobal_serviceDesc, srv)
}

func _SLGlobal_SLGlobalInitNotif_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SLInitMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SLGlobalServer).SLGlobalInitNotif(m, &sLGlobalSLGlobalInitNotifServer{stream})
}

type SLGlobal_SLGlobalInitNotifServer interface {
	Send(*SLGlobalNotif) error
	grpc.ServerStream
}

type sLGlobalSLGlobalInitNotifServer struct {
	grpc.ServerStream
}

func (x *sLGlobalSLGlobalInitNotifServer) Send(m *SLGlobalNotif) error {
	return x.ServerStream.SendMsg(m)
}

func _SLGlobal_SLGlobalsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLGlobalsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLGlobalServer).SLGlobalsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLGlobal/SLGlobalsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLGlobalServer).SLGlobalsGet(ctx, req.(*SLGlobalsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _SLGlobal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLGlobal",
	HandlerType: (*SLGlobalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLGlobalsGet",
			Handler:    _SLGlobal_SLGlobalsGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLGlobalInitNotif",
			Handler:       _SLGlobal_SLGlobalInitNotif_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sl_global.proto",
}
