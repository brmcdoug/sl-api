// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sl_mpls.proto

package service_layer

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// MPLS label actions.
type SlLabelAction int32

const (
	// Reserved. 0x0
	SlLabelAction_SL_LABEL_ACTION_RESERVED SlLabelAction = 0
	// Swap. 0x1
	// Swap outer label and forward.
	// Used at tunnel midpoint for swapping labels.
	SlLabelAction_SL_LABEL_ACTION_SWAP SlLabelAction = 1
	// Pop and forward. 0x2
	// Pop outer label and forward.
	// Used for per CE and per prefix label disposition at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_FORWARD SlLabelAction = 2
	// Pop and lookup IPv4. 0x3
	// Pop and lookup the IPv4 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4 SlLabelAction = 3
	// Pop and lookup IPv6. 0x4
	// Pop and lookup the IPv6 next header in the specified Vrf.
	// Used for per vrf labels at egress PE.
	SlLabelAction_SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6 SlLabelAction = 4
)

var SlLabelAction_name = map[int32]string{
	0: "SL_LABEL_ACTION_RESERVED",
	1: "SL_LABEL_ACTION_SWAP",
	2: "SL_LABEL_ACTION_POP_AND_FORWARD",
	3: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4",
	4: "SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6",
}

var SlLabelAction_value = map[string]int32{
	"SL_LABEL_ACTION_RESERVED":            0,
	"SL_LABEL_ACTION_SWAP":                1,
	"SL_LABEL_ACTION_POP_AND_FORWARD":     2,
	"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV4": 3,
	"SL_LABEL_ACTION_POP_AND_LOOKUP_IPV6": 4,
}

func (x SlLabelAction) String() string {
	return proto.EnumName(SlLabelAction_name, int32(x))
}

func (SlLabelAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{0}
}

// MPLS Label block key.
// This message is used to relay the label block key attributes.
type SLMplsLabelBlockKey struct {
	// Starting label value of the block.
	StartLabel uint32 `protobuf:"varint,1,opt,name=StartLabel,proto3" json:"StartLabel,omitempty"`
	// Label block size.
	// Block size should be <= SLServerResponse.MaxLabelsPerBlock
	LabelBlockSize       uint32   `protobuf:"varint,2,opt,name=LabelBlockSize,proto3" json:"LabelBlockSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsLabelBlockKey) Reset()         { *m = SLMplsLabelBlockKey{} }
func (m *SLMplsLabelBlockKey) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockKey) ProtoMessage()    {}
func (*SLMplsLabelBlockKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{0}
}

func (m *SLMplsLabelBlockKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockKey.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockKey.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockKey.Merge(m, src)
}
func (m *SLMplsLabelBlockKey) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockKey.Size(m)
}
func (m *SLMplsLabelBlockKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockKey.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockKey proto.InternalMessageInfo

func (m *SLMplsLabelBlockKey) GetStartLabel() uint32 {
	if m != nil {
		return m.StartLabel
	}
	return 0
}

func (m *SLMplsLabelBlockKey) GetLabelBlockSize() uint32 {
	if m != nil {
		return m.LabelBlockSize
	}
	return 0
}

// MPLS Label block batch reservation message.
// This message is used to send a batch of label block requests.
// The Oper attributes indicates add or delete operations.
type SLMplsLabelBlockMsg struct {
	// MPLS Label Block Operations.
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// List of label blocks requests.
	// List size should be <= SLServerResponse.MaxLabelBlocksPerRequest
	MplsBlocks           []*SLMplsLabelBlockKey `protobuf:"bytes,2,rep,name=MplsBlocks,proto3" json:"MplsBlocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SLMplsLabelBlockMsg) Reset()         { *m = SLMplsLabelBlockMsg{} }
func (m *SLMplsLabelBlockMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsg) ProtoMessage()    {}
func (*SLMplsLabelBlockMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{1}
}

func (m *SLMplsLabelBlockMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockMsg.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockMsg.Merge(m, src)
}
func (m *SLMplsLabelBlockMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockMsg.Size(m)
}
func (m *SLMplsLabelBlockMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockMsg proto.InternalMessageInfo

func (m *SLMplsLabelBlockMsg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLMplsLabelBlockMsg) GetMplsBlocks() []*SLMplsLabelBlockKey {
	if m != nil {
		return m.MplsBlocks
	}
	return nil
}

// MPLS Label block reservation result.
// This message is used to convey the result status corresponding to
// the label block operation.
type SLMplsLabelBlockMsgRes struct {
	// Corresponding error code.
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Key for which the error code is reported.
	Key                  *SLMplsLabelBlockKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SLMplsLabelBlockMsgRes) Reset()         { *m = SLMplsLabelBlockMsgRes{} }
func (m *SLMplsLabelBlockMsgRes) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsgRes) ProtoMessage()    {}
func (*SLMplsLabelBlockMsgRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{2}
}

func (m *SLMplsLabelBlockMsgRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockMsgRes.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockMsgRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockMsgRes.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockMsgRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockMsgRes.Merge(m, src)
}
func (m *SLMplsLabelBlockMsgRes) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockMsgRes.Size(m)
}
func (m *SLMplsLabelBlockMsgRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockMsgRes.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockMsgRes proto.InternalMessageInfo

func (m *SLMplsLabelBlockMsgRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsLabelBlockMsgRes) GetKey() *SLMplsLabelBlockKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// MPLS Label block batch reservation response.
// This message is used to convey a summary status for the batch operation.
// If there are errors encountered, the Results field would indicate which
// label block reservation failed.
type SLMplsLabelBlockMsgRsp struct {
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results              []*SLMplsLabelBlockMsgRes `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SLMplsLabelBlockMsgRsp) Reset()         { *m = SLMplsLabelBlockMsgRsp{} }
func (m *SLMplsLabelBlockMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockMsgRsp) ProtoMessage()    {}
func (*SLMplsLabelBlockMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{3}
}

func (m *SLMplsLabelBlockMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockMsgRsp.Merge(m, src)
}
func (m *SLMplsLabelBlockMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockMsgRsp.Size(m)
}
func (m *SLMplsLabelBlockMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockMsgRsp proto.InternalMessageInfo

func (m *SLMplsLabelBlockMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLMplsLabelBlockMsgRsp) GetResults() []*SLMplsLabelBlockMsgRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// MPLS Label Block Get Message
// This message is used to query previous label block reservations.
type SLMplsLabelBlockGetMsg struct {
	// MPLS Label Block key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsLabelBlockKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext              bool     `protobuf:"varint,3,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsLabelBlockGetMsg) Reset()         { *m = SLMplsLabelBlockGetMsg{} }
func (m *SLMplsLabelBlockGetMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockGetMsg) ProtoMessage()    {}
func (*SLMplsLabelBlockGetMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{4}
}

func (m *SLMplsLabelBlockGetMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockGetMsg.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockGetMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockGetMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockGetMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockGetMsg.Merge(m, src)
}
func (m *SLMplsLabelBlockGetMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockGetMsg.Size(m)
}
func (m *SLMplsLabelBlockGetMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockGetMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockGetMsg proto.InternalMessageInfo

func (m *SLMplsLabelBlockGetMsg) GetKey() *SLMplsLabelBlockKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsLabelBlockGetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLMplsLabelBlockGetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// MPLS Label Block get message response
// This message is the response to the label block query.
type SLMplsLabelBlockGetMsgRsp struct {
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries              []*SLMplsLabelBlockKey `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SLMplsLabelBlockGetMsgRsp) Reset()         { *m = SLMplsLabelBlockGetMsgRsp{} }
func (m *SLMplsLabelBlockGetMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsLabelBlockGetMsgRsp) ProtoMessage()    {}
func (*SLMplsLabelBlockGetMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{5}
}

func (m *SLMplsLabelBlockGetMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsLabelBlockGetMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsLabelBlockGetMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsLabelBlockGetMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsLabelBlockGetMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsLabelBlockGetMsgRsp.Merge(m, src)
}
func (m *SLMplsLabelBlockGetMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsLabelBlockGetMsgRsp.Size(m)
}
func (m *SLMplsLabelBlockGetMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsLabelBlockGetMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsLabelBlockGetMsgRsp proto.InternalMessageInfo

func (m *SLMplsLabelBlockGetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLMplsLabelBlockGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsLabelBlockGetMsgRsp) GetEntries() []*SLMplsLabelBlockKey {
	if m != nil {
		return m.Entries
	}
	return nil
}

// MPLS Registration message.
// This message is used for MPLS global registration. Clients must register
// before using any MPLS service.
type SLMplsRegMsg struct {
	// Registration Operation
	Oper                 SLRegOp  `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLRegOp" json:"Oper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsRegMsg) Reset()         { *m = SLMplsRegMsg{} }
func (m *SLMplsRegMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsRegMsg) ProtoMessage()    {}
func (*SLMplsRegMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{6}
}

func (m *SLMplsRegMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsRegMsg.Unmarshal(m, b)
}
func (m *SLMplsRegMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsRegMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsRegMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsRegMsg.Merge(m, src)
}
func (m *SLMplsRegMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsRegMsg.Size(m)
}
func (m *SLMplsRegMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsRegMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsRegMsg proto.InternalMessageInfo

func (m *SLMplsRegMsg) GetOper() SLRegOp {
	if m != nil {
		return m.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

// MPLS Registration response message.
// This message is used to convey the result of the MPLS registration.
type SLMplsRegMsgRsp struct {
	// Error code
	ErrStatus            *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SLMplsRegMsgRsp) Reset()         { *m = SLMplsRegMsgRsp{} }
func (m *SLMplsRegMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsRegMsgRsp) ProtoMessage()    {}
func (*SLMplsRegMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{7}
}

func (m *SLMplsRegMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsRegMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsRegMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsRegMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsRegMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsRegMsgRsp.Merge(m, src)
}
func (m *SLMplsRegMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsRegMsgRsp.Size(m)
}
func (m *SLMplsRegMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsRegMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsRegMsgRsp proto.InternalMessageInfo

func (m *SLMplsRegMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

// MPLS Get Global Info message.
// This message is used to query MPLS global capabilities.
type SLMplsGetMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsGetMsg) Reset()         { *m = SLMplsGetMsg{} }
func (m *SLMplsGetMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsGetMsg) ProtoMessage()    {}
func (*SLMplsGetMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{8}
}

func (m *SLMplsGetMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsGetMsg.Unmarshal(m, b)
}
func (m *SLMplsGetMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsGetMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsGetMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsGetMsg.Merge(m, src)
}
func (m *SLMplsGetMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsGetMsg.Size(m)
}
func (m *SLMplsGetMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsGetMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsGetMsg proto.InternalMessageInfo

// MPLS Get Global Info response message.
// This message is used to convey the response to the global capabilities query.
type SLMplsGetMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Maximum labels that can be allocated/freed per label block.
	MaxLabelsPerBlock uint32 `protobuf:"varint,2,opt,name=MaxLabelsPerBlock,proto3" json:"MaxLabelsPerBlock,omitempty"`
	// Maximum label blocks that can be allocated/freed per MplsLabelBlockMsg
	MaxLabelblocksPerLabelblockmsg uint32 `protobuf:"varint,3,opt,name=MaxLabelblocksPerLabelblockmsg,proto3" json:"MaxLabelblocksPerLabelblockmsg,omitempty"`
	// Minimum label value that can be reserved on the platform.
	// MplsLabelBlockKey.StartLabel >= MinStartLabel
	MinStartLabel uint32 `protobuf:"varint,4,opt,name=MinStartLabel,proto3" json:"MinStartLabel,omitempty"`
	// Label table size for the platform.
	// MplsLabelBlockKey.StartLabel <= LabelTableSize
	LabelTableSize uint32 `protobuf:"varint,5,opt,name=LabelTableSize,proto3" json:"LabelTableSize,omitempty"`
	// Max ILM objects within a single IlmMsg message.
	MaxIlmPerIlmmsg uint32 `protobuf:"varint,6,opt,name=MaxIlmPerIlmmsg,proto3" json:"MaxIlmPerIlmmsg,omitempty"`
	// Maximum paths per ILM.
	MaxPathsPerIlm       uint32   `protobuf:"varint,7,opt,name=MaxPathsPerIlm,proto3" json:"MaxPathsPerIlm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsGetMsgRsp) Reset()         { *m = SLMplsGetMsgRsp{} }
func (m *SLMplsGetMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsGetMsgRsp) ProtoMessage()    {}
func (*SLMplsGetMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{9}
}

func (m *SLMplsGetMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsGetMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsGetMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsGetMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsGetMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsGetMsgRsp.Merge(m, src)
}
func (m *SLMplsGetMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsGetMsgRsp.Size(m)
}
func (m *SLMplsGetMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsGetMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsGetMsgRsp proto.InternalMessageInfo

func (m *SLMplsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsGetMsgRsp) GetMaxLabelsPerBlock() uint32 {
	if m != nil {
		return m.MaxLabelsPerBlock
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxLabelblocksPerLabelblockmsg() uint32 {
	if m != nil {
		return m.MaxLabelblocksPerLabelblockmsg
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMinStartLabel() uint32 {
	if m != nil {
		return m.MinStartLabel
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetLabelTableSize() uint32 {
	if m != nil {
		return m.LabelTableSize
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxIlmPerIlmmsg() uint32 {
	if m != nil {
		return m.MaxIlmPerIlmmsg
	}
	return 0
}

func (m *SLMplsGetMsgRsp) GetMaxPathsPerIlm() uint32 {
	if m != nil {
		return m.MaxPathsPerIlm
	}
	return 0
}

// MPLS Get Global Stats response message.
// This message is used to convey the response to the MPLS statistics query.
type SLMplsGetStatsMsgRsp struct {
	// Error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Num of label blocks created.
	LabelBlockCount uint32 `protobuf:"varint,2,opt,name=LabelBlockCount,proto3" json:"LabelBlockCount,omitempty"`
	// Num ILMs added through the service layer.
	IlmCount             uint32   `protobuf:"varint,3,opt,name=IlmCount,proto3" json:"IlmCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsGetStatsMsgRsp) Reset()         { *m = SLMplsGetStatsMsgRsp{} }
func (m *SLMplsGetStatsMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsGetStatsMsgRsp) ProtoMessage()    {}
func (*SLMplsGetStatsMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{10}
}

func (m *SLMplsGetStatsMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsGetStatsMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsGetStatsMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsGetStatsMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsGetStatsMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsGetStatsMsgRsp.Merge(m, src)
}
func (m *SLMplsGetStatsMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsGetStatsMsgRsp.Size(m)
}
func (m *SLMplsGetStatsMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsGetStatsMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsGetStatsMsgRsp proto.InternalMessageInfo

func (m *SLMplsGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsGetStatsMsgRsp) GetLabelBlockCount() uint32 {
	if m != nil {
		return m.LabelBlockCount
	}
	return 0
}

func (m *SLMplsGetStatsMsgRsp) GetIlmCount() uint32 {
	if m != nil {
		return m.IlmCount
	}
	return 0
}

// MPLS Path (or NHLFE) information.
// This message holds the ILM path attributes.
type SLMplsPath struct {
	// One of IPv4 or IPv6 address
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress,proto3" json:"NexthopAddress,omitempty"`
	// Next hop interface.
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface,proto3" json:"NexthopInterface,omitempty"`
	// ECMP load weight metric
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric,proto3" json:"LoadMetric,omitempty"`
	// VRF name
	VrfName string `protobuf:"bytes,4,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Associated MPLS incoming label's action.
	// The label action dictates what to do with the incoming label.
	// Possible actions are:
	//  - SL_LABEL_ACTION_SWAP: SWAP the incoming label with the
	//      specified LabelStack (see below), and forward the packet.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_FORWARD: Pop the label, and forward the
	//      packet to the specified nexthop.
	//      Path attributes: NexthopInterface, VrfName, NexthopAddress.
	//  - SL_LABEL_ACTION_POP_AND_LOOKUP: Pop the label, and lookup the
	//      packet's next header's address in the specified VrfName.
	//      Path attributes: VrfName.
	Action SlLabelAction `protobuf:"varint,5,opt,name=Action,proto3,enum=service_layer.SlLabelAction" json:"Action,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//    1. Primary. The path is the main path to carry traffic.
	//    2. Protected. A primary path with a configured backup path.
	//    3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//    1. Pure Primary i.e. Not Protected and is not a Backup.
	//       => PathId is optional. ProtectedPathBitmap = 0x0
	//    2. Primary and Protected. Path is not a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0x0
	//    3. Primary and Not Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    4. Primary and Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    5. Pure Backup. Protection is not allowed for backup paths.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId,proto3" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//            || |-- path 4
	//            ||-- path 5
	//            |-- path 6
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap,proto3" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack,proto3" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used for backup MPLS path with more than one label,
	// Typically associated with the PQ routers and remote Loop Free
	// Alternatives.
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress        []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress,proto3" json:"RemoteAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SLMplsPath) Reset()         { *m = SLMplsPath{} }
func (m *SLMplsPath) String() string { return proto.CompactTextString(m) }
func (*SLMplsPath) ProtoMessage()    {}
func (*SLMplsPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{11}
}

func (m *SLMplsPath) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsPath.Unmarshal(m, b)
}
func (m *SLMplsPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsPath.Marshal(b, m, deterministic)
}
func (m *SLMplsPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsPath.Merge(m, src)
}
func (m *SLMplsPath) XXX_Size() int {
	return xxx_messageInfo_SLMplsPath.Size(m)
}
func (m *SLMplsPath) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsPath.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsPath proto.InternalMessageInfo

func (m *SLMplsPath) GetNexthopAddress() *SLIpAddress {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *SLMplsPath) GetNexthopInterface() *SLInterface {
	if m != nil {
		return m.NexthopInterface
	}
	return nil
}

func (m *SLMplsPath) GetLoadMetric() uint32 {
	if m != nil {
		return m.LoadMetric
	}
	return 0
}

func (m *SLMplsPath) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *SLMplsPath) GetAction() SlLabelAction {
	if m != nil {
		return m.Action
	}
	return SlLabelAction_SL_LABEL_ACTION_RESERVED
}

func (m *SLMplsPath) GetPathId() uint32 {
	if m != nil {
		return m.PathId
	}
	return 0
}

func (m *SLMplsPath) GetProtectedPathBitmap() []uint64 {
	if m != nil {
		return m.ProtectedPathBitmap
	}
	return nil
}

func (m *SLMplsPath) GetLabelStack() []uint32 {
	if m != nil {
		return m.LabelStack
	}
	return nil
}

func (m *SLMplsPath) GetRemoteAddress() []*SLIpAddress {
	if m != nil {
		return m.RemoteAddress
	}
	return nil
}

// MPLS ILM entry's key.
// This message defines the Incoming Label Map key attributes.
type SLMplsIlmKey struct {
	// Incoming local label.
	LocalLabel           uint32   `protobuf:"varint,1,opt,name=LocalLabel,proto3" json:"LocalLabel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsIlmKey) Reset()         { *m = SLMplsIlmKey{} }
func (m *SLMplsIlmKey) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmKey) ProtoMessage()    {}
func (*SLMplsIlmKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{12}
}

func (m *SLMplsIlmKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmKey.Unmarshal(m, b)
}
func (m *SLMplsIlmKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmKey.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmKey.Merge(m, src)
}
func (m *SLMplsIlmKey) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmKey.Size(m)
}
func (m *SLMplsIlmKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmKey.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmKey proto.InternalMessageInfo

func (m *SLMplsIlmKey) GetLocalLabel() uint32 {
	if m != nil {
		return m.LocalLabel
	}
	return 0
}

// MPLS ILM entry.
// This messages defines an ILM entry.
type SLMplsIlmEntry struct {
	// ILM Key.
	Key *SLMplsIlmKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// List of path (NHLFE) information.
	Paths                []*SLMplsPath `protobuf:"bytes,2,rep,name=Paths,proto3" json:"Paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SLMplsIlmEntry) Reset()         { *m = SLMplsIlmEntry{} }
func (m *SLMplsIlmEntry) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmEntry) ProtoMessage()    {}
func (*SLMplsIlmEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{13}
}

func (m *SLMplsIlmEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmEntry.Unmarshal(m, b)
}
func (m *SLMplsIlmEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmEntry.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmEntry.Merge(m, src)
}
func (m *SLMplsIlmEntry) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmEntry.Size(m)
}
func (m *SLMplsIlmEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmEntry proto.InternalMessageInfo

func (m *SLMplsIlmEntry) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsIlmEntry) GetPaths() []*SLMplsPath {
	if m != nil {
		return m.Paths
	}
	return nil
}

// A batch of MPLS ILM entries.
// This message is used to send a batch of ILM entries.
type SLMplsIlmMsg struct {
	// MPLS Object Operations
	Oper SLObjectOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=service_layer.SLObjectOp" json:"Oper,omitempty"`
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,2,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// List of ILM entries
	MplsIlms             []*SLMplsIlmEntry `protobuf:"bytes,3,rep,name=MplsIlms,proto3" json:"MplsIlms,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SLMplsIlmMsg) Reset()         { *m = SLMplsIlmMsg{} }
func (m *SLMplsIlmMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmMsg) ProtoMessage()    {}
func (*SLMplsIlmMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{14}
}

func (m *SLMplsIlmMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmMsg.Unmarshal(m, b)
}
func (m *SLMplsIlmMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmMsg.Merge(m, src)
}
func (m *SLMplsIlmMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmMsg.Size(m)
}
func (m *SLMplsIlmMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmMsg proto.InternalMessageInfo

func (m *SLMplsIlmMsg) GetOper() SLObjectOp {
	if m != nil {
		return m.Oper
	}
	return SLObjectOp_SL_OBJOP_RESERVED
}

func (m *SLMplsIlmMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmMsg) GetMplsIlms() []*SLMplsIlmEntry {
	if m != nil {
		return m.MplsIlms
	}
	return nil
}

// MPLS ILM result.
// This message is used to convey the result of the ILM entry operation.
type SLMplsIlmRes struct {
	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// ILM Key.
	Key                  *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SLMplsIlmRes) Reset()         { *m = SLMplsIlmRes{} }
func (m *SLMplsIlmRes) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmRes) ProtoMessage()    {}
func (*SLMplsIlmRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{15}
}

func (m *SLMplsIlmRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmRes.Unmarshal(m, b)
}
func (m *SLMplsIlmRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmRes.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmRes.Merge(m, src)
}
func (m *SLMplsIlmRes) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmRes.Size(m)
}
func (m *SLMplsIlmRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmRes.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmRes proto.InternalMessageInfo

func (m *SLMplsIlmRes) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsIlmRes) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// MPLS ILM batch response.
// This message is used to convey the result of the ILM batch operation.
type SLMplsIlmMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,2,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results              []*SLMplsIlmRes `protobuf:"bytes,3,rep,name=Results,proto3" json:"Results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SLMplsIlmMsgRsp) Reset()         { *m = SLMplsIlmMsgRsp{} }
func (m *SLMplsIlmMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmMsgRsp) ProtoMessage()    {}
func (*SLMplsIlmMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{16}
}

func (m *SLMplsIlmMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsIlmMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmMsgRsp.Merge(m, src)
}
func (m *SLMplsIlmMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmMsgRsp.Size(m)
}
func (m *SLMplsIlmMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmMsgRsp proto.InternalMessageInfo

func (m *SLMplsIlmMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmMsgRsp) GetStatusSummary() *SLErrorStatus {
	if m != nil {
		return m.StatusSummary
	}
	return nil
}

func (m *SLMplsIlmMsgRsp) GetResults() []*SLMplsIlmRes {
	if m != nil {
		return m.Results
	}
	return nil
}

// MPLS ILM Get Message
// This message is used to query the attributes of an ILM entry.
type SLMplsIlmGetMsg struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// MPLS ILM key.
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	Key *SLMplsIlmKey `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,3,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext              bool     `protobuf:"varint,4,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SLMplsIlmGetMsg) Reset()         { *m = SLMplsIlmGetMsg{} }
func (m *SLMplsIlmGetMsg) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmGetMsg) ProtoMessage()    {}
func (*SLMplsIlmGetMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{17}
}

func (m *SLMplsIlmGetMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmGetMsg.Unmarshal(m, b)
}
func (m *SLMplsIlmGetMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmGetMsg.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmGetMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmGetMsg.Merge(m, src)
}
func (m *SLMplsIlmGetMsg) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmGetMsg.Size(m)
}
func (m *SLMplsIlmGetMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmGetMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmGetMsg proto.InternalMessageInfo

func (m *SLMplsIlmGetMsg) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmGetMsg) GetKey() *SLMplsIlmKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SLMplsIlmGetMsg) GetEntriesCount() uint32 {
	if m != nil {
		return m.EntriesCount
	}
	return 0
}

func (m *SLMplsIlmGetMsg) GetGetNext() bool {
	if m != nil {
		return m.GetNext
	}
	return false
}

// MPLS ILM Get Message Response.
type SLMplsIlmGetMsgRsp struct {
	// Correlator. This can be used to correlate replies with requests.
	// The Server simply reflects this field back in the reply.
	Correlator uint64 `protobuf:"varint,1,opt,name=Correlator,proto3" json:"Correlator,omitempty"`
	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,2,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation.
	ErrStatus *SLErrorStatus `protobuf:"bytes,3,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries              []*SLMplsIlmEntry `protobuf:"bytes,4,rep,name=Entries,proto3" json:"Entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SLMplsIlmGetMsgRsp) Reset()         { *m = SLMplsIlmGetMsgRsp{} }
func (m *SLMplsIlmGetMsgRsp) String() string { return proto.CompactTextString(m) }
func (*SLMplsIlmGetMsgRsp) ProtoMessage()    {}
func (*SLMplsIlmGetMsgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b0833c71178c7425, []int{18}
}

func (m *SLMplsIlmGetMsgRsp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SLMplsIlmGetMsgRsp.Unmarshal(m, b)
}
func (m *SLMplsIlmGetMsgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SLMplsIlmGetMsgRsp.Marshal(b, m, deterministic)
}
func (m *SLMplsIlmGetMsgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SLMplsIlmGetMsgRsp.Merge(m, src)
}
func (m *SLMplsIlmGetMsgRsp) XXX_Size() int {
	return xxx_messageInfo_SLMplsIlmGetMsgRsp.Size(m)
}
func (m *SLMplsIlmGetMsgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SLMplsIlmGetMsgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SLMplsIlmGetMsgRsp proto.InternalMessageInfo

func (m *SLMplsIlmGetMsgRsp) GetCorrelator() uint64 {
	if m != nil {
		return m.Correlator
	}
	return 0
}

func (m *SLMplsIlmGetMsgRsp) GetEof() bool {
	if m != nil {
		return m.Eof
	}
	return false
}

func (m *SLMplsIlmGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if m != nil {
		return m.ErrStatus
	}
	return nil
}

func (m *SLMplsIlmGetMsgRsp) GetEntries() []*SLMplsIlmEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterEnum("service_layer.SlLabelAction", SlLabelAction_name, SlLabelAction_value)
	proto.RegisterType((*SLMplsLabelBlockKey)(nil), "service_layer.SLMplsLabelBlockKey")
	proto.RegisterType((*SLMplsLabelBlockMsg)(nil), "service_layer.SLMplsLabelBlockMsg")
	proto.RegisterType((*SLMplsLabelBlockMsgRes)(nil), "service_layer.SLMplsLabelBlockMsgRes")
	proto.RegisterType((*SLMplsLabelBlockMsgRsp)(nil), "service_layer.SLMplsLabelBlockMsgRsp")
	proto.RegisterType((*SLMplsLabelBlockGetMsg)(nil), "service_layer.SLMplsLabelBlockGetMsg")
	proto.RegisterType((*SLMplsLabelBlockGetMsgRsp)(nil), "service_layer.SLMplsLabelBlockGetMsgRsp")
	proto.RegisterType((*SLMplsRegMsg)(nil), "service_layer.SLMplsRegMsg")
	proto.RegisterType((*SLMplsRegMsgRsp)(nil), "service_layer.SLMplsRegMsgRsp")
	proto.RegisterType((*SLMplsGetMsg)(nil), "service_layer.SLMplsGetMsg")
	proto.RegisterType((*SLMplsGetMsgRsp)(nil), "service_layer.SLMplsGetMsgRsp")
	proto.RegisterType((*SLMplsGetStatsMsgRsp)(nil), "service_layer.SLMplsGetStatsMsgRsp")
	proto.RegisterType((*SLMplsPath)(nil), "service_layer.SLMplsPath")
	proto.RegisterType((*SLMplsIlmKey)(nil), "service_layer.SLMplsIlmKey")
	proto.RegisterType((*SLMplsIlmEntry)(nil), "service_layer.SLMplsIlmEntry")
	proto.RegisterType((*SLMplsIlmMsg)(nil), "service_layer.SLMplsIlmMsg")
	proto.RegisterType((*SLMplsIlmRes)(nil), "service_layer.SLMplsIlmRes")
	proto.RegisterType((*SLMplsIlmMsgRsp)(nil), "service_layer.SLMplsIlmMsgRsp")
	proto.RegisterType((*SLMplsIlmGetMsg)(nil), "service_layer.SLMplsIlmGetMsg")
	proto.RegisterType((*SLMplsIlmGetMsgRsp)(nil), "service_layer.SLMplsIlmGetMsgRsp")
}

func init() { proto.RegisterFile("sl_mpls.proto", fileDescriptor_b0833c71178c7425) }

var fileDescriptor_b0833c71178c7425 = []byte{
	// 1157 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x71, 0xb6, 0x7f, 0xde, 0x6e, 0xd2, 0xec, 0x2c, 0x54, 0x6e, 0x59, 0x4a, 0x71, 0xf9,
	0x13, 0xad, 0x68, 0x59, 0x95, 0x02, 0x62, 0x85, 0x04, 0x49, 0x9b, 0x2e, 0xa1, 0x49, 0x13, 0xc6,
	0xa5, 0x7b, 0x40, 0xc8, 0x72, 0xd3, 0x69, 0x37, 0xac, 0x1d, 0x5b, 0xe3, 0x29, 0x6a, 0xf8, 0x04,
	0x08, 0x71, 0xe1, 0xc6, 0x05, 0xae, 0x5c, 0x38, 0x72, 0x43, 0xe2, 0xcb, 0xf0, 0x45, 0xd0, 0x8c,
	0x67, 0x62, 0x3b, 0x8e, 0x9b, 0x94, 0x70, 0xab, 0xdf, 0xfc, 0xde, 0xeb, 0x6f, 0x7e, 0xef, 0xcd,
	0x7b, 0x2f, 0x50, 0x0a, 0x5d, 0xdb, 0x0b, 0xdc, 0x70, 0x27, 0xa0, 0x3e, 0xf3, 0x51, 0x29, 0x24,
	0xf4, 0xbb, 0x7e, 0x8f, 0xd8, 0xae, 0x33, 0x24, 0x74, 0xfd, 0x95, 0xd0, 0xb5, 0x7b, 0xbe, 0xe7,
	0xf9, 0x03, 0x9b, 0x0d, 0x03, 0x22, 0x51, 0xe6, 0x37, 0xf0, 0xc0, 0x6a, 0xb5, 0x03, 0x37, 0x6c,
	0x39, 0x67, 0xc4, 0xad, 0xbb, 0x7e, 0xef, 0xc5, 0x11, 0x19, 0xa2, 0x0d, 0x00, 0x8b, 0x39, 0x94,
	0x09, 0xab, 0xa1, 0x6d, 0x6a, 0xd5, 0x12, 0x4e, 0x58, 0xd0, 0xdb, 0x50, 0x8e, 0x1d, 0xac, 0xfe,
	0xf7, 0xc4, 0x28, 0x08, 0xcc, 0x98, 0xd5, 0xfc, 0x41, 0xcb, 0xc6, 0x6f, 0x87, 0x97, 0x68, 0x1b,
	0x8a, 0x9d, 0x80, 0x50, 0x11, 0xb9, 0xbc, 0xbb, 0xb6, 0x93, 0xe2, 0xba, 0x63, 0xb5, 0x3a, 0x67,
	0xdf, 0x92, 0x1e, 0xeb, 0x04, 0x58, 0xc0, 0x50, 0x1d, 0x80, 0xc7, 0x10, 0xee, 0xa1, 0x51, 0xd8,
	0xd4, 0xab, 0x77, 0x77, 0xcd, 0x8c, 0x53, 0xe6, 0x1a, 0x38, 0xe1, 0x65, 0xfe, 0xa8, 0xc1, 0xea,
	0x04, 0x2a, 0x98, 0x84, 0xe8, 0x09, 0x2c, 0x37, 0x28, 0xb5, 0x98, 0xc3, 0xae, 0x42, 0x41, 0xe9,
	0xee, 0xee, 0xc3, 0x4c, 0xf4, 0x06, 0xa5, 0xbe, 0xc4, 0xe0, 0x18, 0x8e, 0xf6, 0x40, 0x3f, 0x22,
	0x43, 0x71, 0xfd, 0xd9, 0x38, 0x71, 0xb8, 0xf9, 0x6b, 0x0e, 0x99, 0x30, 0x40, 0x75, 0x28, 0x45,
	0xa1, 0xad, 0x2b, 0xcf, 0x73, 0xe8, 0x70, 0x26, 0x42, 0x69, 0x17, 0xf4, 0x29, 0x2c, 0x62, 0x12,
	0x5e, 0xb9, 0x4c, 0x89, 0xf5, 0xd6, 0x14, 0x62, 0x91, 0x10, 0x58, 0x79, 0x99, 0x3f, 0x4d, 0xe0,
	0xf7, 0x94, 0x30, 0x9e, 0x3a, 0x79, 0x61, 0xed, 0x56, 0x17, 0x46, 0x26, 0xdc, 0x6b, 0x0c, 0x18,
	0xed, 0x93, 0x70, 0xdf, 0xbf, 0x1a, 0x30, 0x59, 0x2e, 0x29, 0x1b, 0x32, 0x60, 0xf1, 0x29, 0x61,
	0xc7, 0xe4, 0x9a, 0x19, 0xfa, 0xa6, 0x56, 0x5d, 0xc2, 0xea, 0xd3, 0xfc, 0x5d, 0x83, 0xb5, 0xc9,
	0x74, 0xb8, 0x62, 0x15, 0xd0, 0x1b, 0xfe, 0x85, 0x60, 0xb4, 0x84, 0xf9, 0x9f, 0xe9, 0x84, 0x16,
	0x6e, 0x97, 0xd0, 0x4f, 0x60, 0x51, 0xb2, 0x32, 0xf4, 0x99, 0x0b, 0x4d, 0xb9, 0x98, 0x4f, 0xe0,
	0x5e, 0x74, 0x8e, 0xc9, 0x25, 0x57, 0xeb, 0x51, 0xaa, 0xd0, 0x57, 0x33, 0xa1, 0x30, 0xb9, 0x54,
	0x55, 0x6e, 0xb6, 0x61, 0x25, 0xe9, 0xcb, 0xaf, 0x36, 0x47, 0x65, 0x9a, 0x65, 0x45, 0x25, 0x52,
	0xca, 0xfc, 0xa7, 0xa0, 0xe2, 0xc7, 0xd2, 0xcd, 0x53, 0xf9, 0xef, 0xc2, 0xfd, 0xb6, 0x73, 0x2d,
	0x74, 0x08, 0xbb, 0x84, 0x0a, 0x2d, 0x64, 0x5e, 0xb3, 0x07, 0xe8, 0x10, 0x36, 0x94, 0xf1, 0x4c,
	0x3c, 0xc8, 0x2e, 0xa1, 0xf1, 0x97, 0x17, 0x5e, 0x8a, 0x9c, 0x97, 0xf0, 0x14, 0x14, 0x7a, 0x13,
	0x4a, 0xed, 0xfe, 0x20, 0xd1, 0x9c, 0x8a, 0xc2, 0x2d, 0x6d, 0x1c, 0xf5, 0xa7, 0x13, 0xe7, 0xcc,
	0x25, 0xa2, 0x3f, 0xdd, 0x49, 0xf4, 0xa7, 0x91, 0x15, 0x55, 0x61, 0xa5, 0xed, 0x5c, 0x37, 0x5d,
	0xaf, 0x4b, 0x68, 0xd3, 0xf5, 0x38, 0x8d, 0x05, 0x01, 0x1c, 0x37, 0xf3, 0x88, 0x6d, 0xe7, 0xba,
	0xeb, 0xb0, 0xe7, 0x61, 0x64, 0x34, 0x16, 0xa3, 0x88, 0x69, 0xab, 0xf9, 0x8b, 0x06, 0x2f, 0x8f,
	0x54, 0xe6, 0x4a, 0x85, 0xff, 0x83, 0xd4, 0x55, 0x58, 0x89, 0xeb, 0x2d, 0xf9, 0x80, 0xc6, 0xcd,
	0x68, 0x1d, 0x96, 0x9a, 0xae, 0x17, 0x41, 0x22, 0x41, 0x47, 0xdf, 0xe6, 0x9f, 0x3a, 0x40, 0x44,
	0x8d, 0x13, 0x46, 0x75, 0x28, 0xf3, 0xc7, 0xf5, 0xdc, 0x0f, 0x6a, 0xe7, 0xe7, 0x94, 0x84, 0x8a,
	0xd5, 0x7a, 0x86, 0x55, 0x53, 0x21, 0xf0, 0x98, 0x07, 0x3a, 0x84, 0x8a, 0xb4, 0x34, 0x07, 0x8c,
	0xd0, 0x0b, 0xa7, 0x47, 0xe4, 0x7b, 0x9b, 0x10, 0x45, 0x21, 0x70, 0xc6, 0x87, 0xcf, 0x9b, 0x96,
	0xef, 0x9c, 0xb7, 0x09, 0xa3, 0xfd, 0x9e, 0x24, 0x9e, 0xb0, 0xf0, 0xd6, 0x70, 0x4a, 0x2f, 0x8e,
	0x1d, 0x8f, 0x88, 0x7c, 0x2f, 0x63, 0xf5, 0x89, 0xf6, 0x60, 0xa1, 0xd6, 0x63, 0x7d, 0x7f, 0x20,
	0x32, 0x5c, 0xce, 0x6a, 0xea, 0x0a, 0x89, 0x22, 0x0c, 0x96, 0x58, 0xb4, 0x0a, 0x0b, 0x5c, 0x83,
	0xe6, 0xb9, 0x4c, 0xb7, 0xfc, 0x42, 0x8f, 0xe1, 0x41, 0x97, 0xfa, 0x8c, 0xf4, 0x18, 0x39, 0xe7,
	0xa6, 0x7a, 0x9f, 0x79, 0x4e, 0x60, 0x2c, 0x6e, 0xea, 0xd5, 0x22, 0x9e, 0x74, 0x24, 0x98, 0xf3,
	0x7f, 0x60, 0x31, 0xa7, 0xf7, 0xc2, 0x58, 0xda, 0xd4, 0x05, 0xf3, 0x91, 0x05, 0x7d, 0x06, 0x25,
	0x4c, 0x3c, 0x9f, 0x11, 0x25, 0xf2, 0xb2, 0x68, 0x2a, 0x37, 0x89, 0x9c, 0x76, 0x30, 0x77, 0xd4,
	0x3b, 0x6e, 0xba, 0x9e, 0x9c, 0xcd, 0x2d, 0xbf, 0xe7, 0xb8, 0xa9, 0xd9, 0x1c, 0x5b, 0xcc, 0x00,
	0xca, 0x23, 0x3c, 0x6f, 0x4b, 0x43, 0xb4, 0x9d, 0x6c, 0xd9, 0xaf, 0x4e, 0x6c, 0x67, 0x51, 0xec,
	0xa8, 0x57, 0xbf, 0x07, 0x77, 0x44, 0x45, 0xcb, 0xd9, 0xb1, 0x36, 0xd1, 0x81, 0x23, 0x70, 0x84,
	0xe3, 0x35, 0x1f, 0x53, 0xfc, 0x0f, 0xe3, 0x7d, 0x03, 0x60, 0xdf, 0xa7, 0x94, 0xb8, 0x0e, 0xf3,
	0xa9, 0xa8, 0x9f, 0x22, 0x4e, 0x58, 0xd0, 0xc7, 0xb0, 0x24, 0x83, 0xab, 0x9e, 0xfc, 0x5a, 0xde,
	0x25, 0xc4, 0x85, 0xf1, 0x08, 0x6e, 0x0e, 0x13, 0xcc, 0xe6, 0x1d, 0xf5, 0xdb, 0xc9, 0x51, 0x3f,
	0x55, 0x46, 0xf3, 0x0f, 0x4d, 0xf5, 0xdb, 0x48, 0x15, 0xde, 0x04, 0xd2, 0x37, 0xd5, 0x32, 0x37,
	0xcd, 0x0c, 0xff, 0xc2, 0xed, 0x87, 0xff, 0x07, 0xf1, 0xf0, 0x8f, 0xc4, 0xca, 0xa5, 0x9a, 0x1a,
	0xf9, 0xbf, 0x25, 0xe9, 0xca, 0x59, 0x3f, 0x8d, 0xee, 0xed, 0x14, 0xc9, 0x2c, 0x01, 0xfa, 0xcd,
	0x4b, 0x40, 0x31, 0xbd, 0x04, 0xfc, 0xa5, 0x01, 0x1a, 0x23, 0x38, 0x8b, 0xa4, 0x72, 0x3b, 0x28,
	0xe4, 0x6c, 0x07, 0xfa, 0xed, 0x6a, 0xe0, 0xa3, 0x78, 0x3b, 0x28, 0xce, 0x52, 0x89, 0x0a, 0xfd,
	0xe8, 0x6f, 0x0d, 0x4a, 0xa9, 0x5e, 0x84, 0x1e, 0x82, 0x61, 0xb5, 0xec, 0x56, 0xad, 0xde, 0x68,
	0xd9, 0xb5, 0xfd, 0x93, 0x66, 0xe7, 0xd8, 0xc6, 0x0d, 0xab, 0x81, 0x4f, 0x1b, 0x07, 0x95, 0x97,
	0x90, 0xc1, 0xc7, 0x48, 0xfa, 0xd4, 0x7a, 0x56, 0xeb, 0x56, 0x34, 0xb4, 0x05, 0xaf, 0x8f, 0x9f,
	0x74, 0x3b, 0x5d, 0xbb, 0x76, 0x7c, 0x60, 0x1f, 0x76, 0xf0, 0xb3, 0x1a, 0x3e, 0xa8, 0x14, 0xd0,
	0x3b, 0xb0, 0x95, 0x07, 0x6a, 0x75, 0x3a, 0x47, 0x5f, 0x75, 0xed, 0x66, 0xf7, 0x74, 0xaf, 0xa2,
	0xcf, 0x06, 0xfc, 0xb0, 0x52, 0xdc, 0xfd, 0x79, 0x41, 0x4d, 0x0f, 0xf1, 0x66, 0xbf, 0x80, 0xbb,
	0xa3, 0x65, 0xa5, 0x13, 0xa0, 0xc9, 0xc9, 0x8f, 0x16, 0x99, 0xf5, 0x8d, 0x1b, 0x0e, 0x79, 0x0a,
	0x3f, 0x87, 0xe5, 0xd1, 0xc8, 0xcc, 0x89, 0x14, 0xe5, 0x3b, 0x27, 0x52, 0x5c, 0x0c, 0x58, 0xf5,
	0x3e, 0x35, 0x7c, 0x6f, 0x0e, 0xb7, 0x95, 0x77, 0x98, 0x1c, 0xdc, 0xb6, 0x2a, 0xbb, 0x78, 0xd6,
	0x76, 0x02, 0x64, 0x4e, 0xdf, 0xa8, 0xd7, 0x67, 0xd9, 0xba, 0xc3, 0x00, 0x5d, 0x64, 0x7f, 0x23,
	0x71, 0x21, 0xa6, 0x79, 0xcb, 0x3b, 0x54, 0x67, 0x82, 0xf1, 0xff, 0x33, 0x4a, 0x59, 0xd3, 0xf5,
	0x72, 0x53, 0x16, 0xf5, 0xaa, 0x1c, 0xa1, 0xe3, 0x46, 0xf6, 0x65, 0xa2, 0xaf, 0x72, 0xb2, 0xb9,
	0x78, 0xc9, 0xf2, 0x8d, 0x9b, 0xcf, 0x79, 0xc8, 0x13, 0xb8, 0x9f, 0xa0, 0x67, 0x31, 0x4a, 0x1c,
	0x6f, 0x2e, 0x92, 0x55, 0xed, 0xb1, 0x86, 0xbe, 0x4e, 0x37, 0x0d, 0x19, 0x76, 0x7e, 0xba, 0x3c,
	0xf8, 0xd9, 0x82, 0xf8, 0x11, 0xfd, 0xfe, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x28, 0x89, 0xa9,
	0xaf, 0x7b, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SLMplsOperClient is the client API for SLMplsOper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SLMplsOperClient interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error)
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error)
}

type sLMplsOperClient struct {
	cc *grpc.ClientConn
}

func NewSLMplsOperClient(cc *grpc.ClientConn) SLMplsOperClient {
	return &sLMplsOperClient{cc}
}

func (c *sLMplsOperClient) SLMplsRegOp(ctx context.Context, in *SLMplsRegMsg, opts ...grpc.CallOption) (*SLMplsRegMsgRsp, error) {
	out := new(SLMplsRegMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsRegOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGet(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetMsgRsp, error) {
	out := new(SLMplsGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsGetStats(ctx context.Context, in *SLMplsGetMsg, opts ...grpc.CallOption) (*SLMplsGetStatsMsgRsp, error) {
	out := new(SLMplsGetStatsMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsGetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockOp(ctx context.Context, in *SLMplsLabelBlockMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockMsgRsp, error) {
	out := new(SLMplsLabelBlockMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsLabelBlockGet(ctx context.Context, in *SLMplsLabelBlockGetMsg, opts ...grpc.CallOption) (*SLMplsLabelBlockGetMsgRsp, error) {
	out := new(SLMplsLabelBlockGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsLabelBlockGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOp(ctx context.Context, in *SLMplsIlmMsg, opts ...grpc.CallOption) (*SLMplsIlmMsgRsp, error) {
	out := new(SLMplsIlmMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmGet(ctx context.Context, in *SLMplsIlmGetMsg, opts ...grpc.CallOption) (*SLMplsIlmGetMsgRsp, error) {
	out := new(SLMplsIlmGetMsgRsp)
	err := c.cc.Invoke(ctx, "/service_layer.SLMplsOper/SLMplsIlmGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sLMplsOperClient) SLMplsIlmOpStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmOpStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLMplsOper_serviceDesc.Streams[0], "/service_layer.SLMplsOper/SLMplsIlmOpStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmOpStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmOpStreamClient interface {
	Send(*SLMplsIlmMsg) error
	Recv() (*SLMplsIlmMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmOpStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Send(m *SLMplsIlmMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamClient) Recv() (*SLMplsIlmMsgRsp, error) {
	m := new(SLMplsIlmMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sLMplsOperClient) SLMplsIlmGetStream(ctx context.Context, opts ...grpc.CallOption) (SLMplsOper_SLMplsIlmGetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SLMplsOper_serviceDesc.Streams[1], "/service_layer.SLMplsOper/SLMplsIlmGetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sLMplsOperSLMplsIlmGetStreamClient{stream}
	return x, nil
}

type SLMplsOper_SLMplsIlmGetStreamClient interface {
	Send(*SLMplsIlmGetMsg) error
	Recv() (*SLMplsIlmGetMsgRsp, error)
	grpc.ClientStream
}

type sLMplsOperSLMplsIlmGetStreamClient struct {
	grpc.ClientStream
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Send(m *SLMplsIlmGetMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamClient) Recv() (*SLMplsIlmGetMsgRsp, error) {
	m := new(SLMplsIlmGetMsgRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SLMplsOperServer is the server API for SLMplsOper service.
type SLMplsOperServer interface {
	// SLMplsRegMsg.Oper = SL_REGOP_REGISTER.
	//     Global MPLS registration.
	//     A client Must Register BEFORE MPLS objects can be added/modified.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_UNREGISTER.
	//     Global MPLS un-registration.
	//     This call is used to end all MPLS notifications and unregister any
	//     interest in MPLS object configuration.
	//     This call cleans up all MPLS objects previously requested.
	//
	// SLMplsRegMsg.Oper = SL_REGOP_EOF.
	//     MPLS End Of File.
	//     After Registration, the client is expected to send an EOF
	//     message to convey the end of replay of the client's known objects.
	//     This is especially useful under certain restart scenarios when the
	//     client and the server are trying to synchronize their MPLS objects.
	SLMplsRegOp(context.Context, *SLMplsRegMsg) (*SLMplsRegMsgRsp, error)
	// Retrieve global MPLS info from the server.
	SLMplsGet(context.Context, *SLMplsGetMsg) (*SLMplsGetMsgRsp, error)
	// Retrieve global MPLS Stats from the server.
	SLMplsGetStats(context.Context, *SLMplsGetMsg) (*SLMplsGetStatsMsgRsp, error)
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_ADD.
	//     Add a contiguous label block.
	//     Add request may fail if the full block cannot be allocated.
	//
	// SLMplsLabelBlockMsg.Oper = SL_OBJOP_DELETE.
	//     Delete a contiguous label block.
	//     Delete request may fail if the block is in use or the keys don't
	//     match the keys used on add.
	SLMplsLabelBlockOp(context.Context, *SLMplsLabelBlockMsg) (*SLMplsLabelBlockMsgRsp, error)
	// Retrieve Label Block attributes.
	SLMplsLabelBlockGet(context.Context, *SLMplsLabelBlockGetMsg) (*SLMplsLabelBlockGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOp(context.Context, *SLMplsIlmMsg) (*SLMplsIlmMsgRsp, error)
	// Retrieve MPLS ILM entry attributes.
	SLMplsIlmGet(context.Context, *SLMplsIlmGetMsg) (*SLMplsIlmGetMsgRsp, error)
	// SLMplsIlmMsg.Oper = SL_OBJOP_ADD:
	//     Add incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_UPDATE:
	//     Update incoming label map entry.
	//
	// SLMplsIlmMsg.Oper = SL_OBJOP_DELETE:
	//     Delete incoming label map entry.
	SLMplsIlmOpStream(SLMplsOper_SLMplsIlmOpStreamServer) error
	// Stream-Get of incoming label map
	SLMplsIlmGetStream(SLMplsOper_SLMplsIlmGetStreamServer) error
}

func RegisterSLMplsOperServer(s *grpc.Server, srv SLMplsOperServer) {
	s.RegisterService(&_SLMplsOper_serviceDesc, srv)
}

func _SLMplsOper_SLMplsRegOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsRegMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsRegOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsRegOp(ctx, req.(*SLMplsRegMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGet(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsGetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsGetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsGetStats(ctx, req.(*SLMplsGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockOp(ctx, req.(*SLMplsLabelBlockMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsLabelBlockGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsLabelBlockGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsLabelBlockGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsLabelBlockGet(ctx, req.(*SLMplsLabelBlockGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmOp(ctx, req.(*SLMplsIlmMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SLMplsIlmGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service_layer.SLMplsOper/SLMplsIlmGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SLMplsOperServer).SLMplsIlmGet(ctx, req.(*SLMplsIlmGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SLMplsOper_SLMplsIlmOpStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmOpStream(&sLMplsOperSLMplsIlmOpStreamServer{stream})
}

type SLMplsOper_SLMplsIlmOpStreamServer interface {
	Send(*SLMplsIlmMsgRsp) error
	Recv() (*SLMplsIlmMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmOpStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Send(m *SLMplsIlmMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmOpStreamServer) Recv() (*SLMplsIlmMsg, error) {
	m := new(SLMplsIlmMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SLMplsOper_SLMplsIlmGetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SLMplsOperServer).SLMplsIlmGetStream(&sLMplsOperSLMplsIlmGetStreamServer{stream})
}

type SLMplsOper_SLMplsIlmGetStreamServer interface {
	Send(*SLMplsIlmGetMsgRsp) error
	Recv() (*SLMplsIlmGetMsg, error)
	grpc.ServerStream
}

type sLMplsOperSLMplsIlmGetStreamServer struct {
	grpc.ServerStream
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Send(m *SLMplsIlmGetMsgRsp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sLMplsOperSLMplsIlmGetStreamServer) Recv() (*SLMplsIlmGetMsg, error) {
	m := new(SLMplsIlmGetMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SLMplsOper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service_layer.SLMplsOper",
	HandlerType: (*SLMplsOperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SLMplsRegOp",
			Handler:    _SLMplsOper_SLMplsRegOp_Handler,
		},
		{
			MethodName: "SLMplsGet",
			Handler:    _SLMplsOper_SLMplsGet_Handler,
		},
		{
			MethodName: "SLMplsGetStats",
			Handler:    _SLMplsOper_SLMplsGetStats_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockOp",
			Handler:    _SLMplsOper_SLMplsLabelBlockOp_Handler,
		},
		{
			MethodName: "SLMplsLabelBlockGet",
			Handler:    _SLMplsOper_SLMplsLabelBlockGet_Handler,
		},
		{
			MethodName: "SLMplsIlmOp",
			Handler:    _SLMplsOper_SLMplsIlmOp_Handler,
		},
		{
			MethodName: "SLMplsIlmGet",
			Handler:    _SLMplsOper_SLMplsIlmGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SLMplsIlmOpStream",
			Handler:       _SLMplsOper_SLMplsIlmOpStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SLMplsIlmGetStream",
			Handler:       _SLMplsOper_SLMplsIlmGetStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sl_mpls.proto",
}
